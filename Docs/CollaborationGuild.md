# 軟體開發專案協作指南

v0.0.3, last update：2025/7/27

---

# 概論

你在一個專案下進行工作，使用者將會逐步提出多次需求，每個需求逐步迭代，進而完善專案。為了達成使用者需求，執行多次「Mission」。一個完整的「Mission」由以下部分組成
- Row Idea：使用者的初步需求
- Requirement：經討論溝通後，確認為可具體描述或可量化的目標
- Plan：制定用以實現 Requirement 的可執行方案，包含一個或多個Task
	- Tasks：方案內的多個任務
		- 實際產出，如代碼
		- 相關文件的更新
- Delivery：最終產出的成果，皆包含在代碼庫中並使用git進行版本追蹤，通常包含下面兩項：
	- Output：實質產出的代碼、包含對應文件
	- Asset：其他值得紀錄的輔助文件，例如教訓（lesson learned）或更新的原則等，文件規範將於後續提及

---

# 工作流程三大階段

## I. Plan （計畫階段）

此為和使用者互動最多的階段。
逐步將使用者的粗略需求 Idea 轉換為細部具體目標 Requirement，最終轉為可執行方案 Plan，以供後續「執行」階段使用。
經由討論，一個 Mission 輪廓將從模糊逐漸變得清晰具體。
若以資訊完整度及涵蓋範圍，可再細分為下面幾項子流程：

1. 確認基礎需求 Ideal，產出Requirement
    - 簡潔重複使用者所提出的需求，若有明顯缺失的資訊或指令不明確，可在此時直接提出
2. 分析及建立系統架構設計
    - 依照需求進行初步規劃，檢視是否需要調整專案整體架構，例如新增組件，或修改現有組件之間的關係
    - 此時應針對關聯到的組件範圍，繪製修改前後的架構對比圖（如無法輸出圖片，可使用mermaid 格式），以供使用者確認
    - 若遇以下或類似場景，可直接報告對專案架構無影響，無需等待使用者確認
	    - 使用現成的抽象設計繼續實作
	    - 基於現有同質性的組件進行複製修改
	    - 單純局部邏輯的修改
3. 拆分任務 Task，完成細部Plan
    - 若預計建立多個組件協同實現需求，則各組件應依照合理順序，除了實作外單獨進行測試及文檔撰寫
    - 例如抽象層和實作層，應該拆解為兩個任務分別進行
4. 細節決策
    - 若有多種不同的技術棧、算法、套件等 approach 時，提示你的初步建議
    - 若各選項間性質相似性高，則其他備選方案應一併列出，並簡略敘述差異，說明你選擇的原因
    - 若考慮用新引入的套件，應該先查詢是否有安全性及相容性問題，一併進行評估。若套件管理工具提供audit功能，應適當利用

## II. Execution （執行階段）

- 依照計畫中的 Task 順序逐步執行，每個 Task 需包含下面幾項子流程：
	- 開發、除錯、重構（如有必要）
	    - 主要工作：撰寫代碼以實現當前 Task 。如測試環節發生錯誤，定位問題所在後，應重新分析解決方法，並紀錄問題所在。
  	- Review
	    - 主要工作：檢驗產出成果品質，例如是否符合各種開發原則，或是有算法優化空間。
	- 測試
	    - 主要工作：
			- 撰寫測試程式及設計 Test Case。
			- 運行測試
	    - 注意：
			- 撰寫 Test Case 時應檢查計畫 Task 內容，以確保產出代碼能符合初始需求，同時應分析開發過程產出的代碼邏輯，以確保測試覆蓋率。
			- 測試行為以單元測試為主，減少或避免整合測試。

- 若使用者發現工作方向或成果未如預期時，將會手動取消進行中的工作並進行回滾，然後重新開始新的工作。

## III. Delivery （交付階段）

至此具體成果已經產出，開始執行收尾工作。
1. 驗證
    - 再次檢查實際產出代碼、測試結果等數據資訊，確保滿足計畫需求/目標。
    - 檢查ADR、Caveats以及Mission文件是否正確紀錄及更新。
2. 總結
    - 若有必要，更新專案級別文件，如 README 、 Handbooks
    - 準備 commit message，然後回報使用者。
    - 使用者確認同意後，才能進行下一階段歸檔。
3. 歸檔
    - 刪除測試用的暫存資料，例如中繼檔案（不要刪除測試程式）。
    - 若該類型檔案後續仍需使用，視情況加入 `.gitignore`清單。
    - 將最終成果加入 repository 並建立 commit。

---

# 永遠遵循

## A. 基本原則

1. 溝通：
	1. 統一語言：交談和文件編寫均使用繁體中文，並以台灣用語為主。若涉及專有名詞，且該名詞無通用標準翻譯或容易混淆，則使用原文。若未來需要英文文件，將會另行編寫或翻譯。
	2. 語意及態度：交談時使用中性詞彙，並基於客觀事實及邏輯分析表達，減少主觀意見，如讚美或感謝等。所謂中性，指情緒中性及立場中性等。
	3. 使用者理解：使用者對於技術的理解可能不盡正確，指令/需求可能有誤。使用者指令模糊時，應主動提問確認。
	4. 開始一個新的 Work 時，都應重新讀取專案內容，不能僅依靠記憶。先評估、選擇並報告當前擔任的角色（可能同時兼任多個角色）及主要職責，然後敘述當前 Work 的Goal。
2. 專案管理：
	1. 使用者的需求可能頻繁修改，因此不使用傳統專案管理方法中的「變更流程」及「生命週期管理」。遇到較大規模的需求調整或重構，使用者會明確指示，包含新的需求以及如何修改現有計畫（包含文檔），若無明確指示，則僅需在 commit message 或 ADR 文件中進行相應紀錄，這些文件隨後會納入版本控制中。
	2. 不需考慮 CI/CD 流程。
3. 研究及問題解決方法：
	1. 無論何時，均應啟用深度思考模式。
	2. 先搜尋是否有合適的現成解決方案，以高階封裝的工具為優先，避免重複造輪子。但須權衡該工具成熟度、未來性以及應用負擔（避免 Overkill）。
	3. 不需處理的信息：忽略 formatter 或 linter 等輔助程式中單純對於排版的警告，僅處理語法錯誤或 Deprecated 等對於程式運行可能造成直接影響的問題。
4. 編碼品質與架構設計：
	1. 輸出成果必須以可拓展性、高可維護性為最優先。開發及 Review 時，都應反覆思考並檢查結構是否遵循 **GRASP**、**SOLID** 等原則，且排版、命名、文件及語意等是否符合 **Clean Code** 原則。
	2. 建立任何物件或資產時，應遵守單一來源（Single Truth of Source）原則，以引用、繼承、擴充、代理為原則，避免資料複製或重複定義。
	3. 良好的命名：
		1. 不要將型別直接編碼名稱中。例如不要為interface加上I開頭、使用Hungarian Notation風格或使用如userList等名稱。但GraphQL SDL定義或資料庫schema等有慣例或規範等特殊情況例外。
		2. function/ method，應該使用動詞表達，變數應該使用名詞表達，array/ list等結構使用複數名詞，boolean變數使用is/ has/ can/ able等。
		3. 命名應該能清楚表達語意，禁止使用data、obj、temp、i、j等難以判斷用途之名稱。
	4. 針對較大規模專案，依照 Domain-Driven Develop 評估，切分為多個模組。各模組間嚴格以最低耦合度封裝，秉持單一職責原則，並考慮以微服務方式實作，以提升部署彈性及可拓展性。
	5. 未來可能會隨版本異動的業務邏輯，應從代碼中抽離，獨立並使用與代碼無關之純邏輯形式表達，例如使用專門業務邏輯引擎驅動，或自定義的描述文件。
	6. 除非使用者明確指示，開發行為如文件格式或代碼風格等，應符合業界慣例或公約。
	7. 基於安全性考量，對於所有非可控之外部輸入/操作應永遠檢驗，包含但不限於使用者輸入、缺乏可信度的的三方套件、API endpoint、網路資源或磁碟檔案等。針對合理輸入值，以條件邏輯處理：對於異常值，以try-catch 方式例外處理。
	8. 註釋應該謹慎，只針對不易直觀理解或特殊狀況註釋，避免無意義注釋干擾閱讀。例如下面時機：
		- 參考的物件行數距離較遠或跨文件。
		- 使用了特殊技巧或迂迴的方式（黑魔法）。
		- 經過與使用者反覆討論或經過多次修改才確認的邏輯。
	9. 環境依賴：
		- 規劃架構時，盡量避免依賴特定作業系統、硬體或特殊權限（如 Redis、systemd、Registry 等）。可簡易下載執行、無須特殊權限且跨平台的外部程式（如 OpenCV）不受此限。
		- 涉及作業系統 I/O 時及進程管理時，應盡量跨平台相容。
		- 專案中任何涉及運行環境相關的參數，均獨立儲存於設定檔案，不可硬編碼。套件依賴相關應用專業套件/虛擬環境管理工具。

## B. 通用編程及專案實踐

1. 技術棧選擇：
	1. 資料庫操作：優先使用 ORM/ODM 框架，除非使用者明確指示效能為第一優先，才使用原生 SQL。
	2. 前後端協議選擇：
		1. 應依照實際場景選擇使用API規範，以 GraphQL 優先，OpenAPI（RESTful）次之。前端應設計為具有 Route 的 SPA（Single Page Application），其次使用MPA SSR，避免傳統CSR架構。
		2. GraphQL的Type/Input命名，使用對應的suffix，Mutation操作則使用get、delete、update、create等動詞轉作為prefix。
		3. 依照OAuth 2.0 慣例設計使用者登入流程。
		4. 基於分散式服務需求，避免設計依賴後端狀態的請求。
	3. 根據「Single Source of Truth」原則，針對微服務或前後端等通信，雙邊實體均需持有資料定義的場景時。先使用Code First方式定義「通用」資料結構物件，然後將該文件以工具轉換為「專用」文件。例：使用Python的`Pydantic`或`Strawberry`套件定義，透過`Strawberry CLI`轉換為 .graphql SDL 定義檔案，再使用`Graphql Codegen`進一步轉換為前端使用的ts型別。
2. 文件規範及目錄結構：
	1. 組態檔：設計需同時供專案程式及使用者操作，用以儲存如常數、 DAG/flow 流程、parse 規則、及預設組態資訊等資料，優先使用 yaml 格式，前端程式則使用 json 格式，禁止使用 .ini 檔。但若涉及環境相關，例如因部署環境不同（生產、開發、測試）而有所差異的資訊，則應另儲存於.env檔案。
	2. 所有文字文件應在開頭或結尾處加上最後更新時間資訊。
	3. 專案目錄結構，下面為第一層級，除`README.md`外均為可選：
		- Docs/
			- Arch/：放置組件關係圖、資料流程圖、外部資源網路圖等，只儲存當前版本，更新時應該覆蓋舊資料或刪除舊資料。
			- Handbooks/：技術相關文件，例如API相關文檔，或是部署流程等。
			- Caveats.md：紀錄血淚教訓（lesson learned），避免後續再次踩坑。
				- 每項總共不超過200字，最多1個子階層。
				- 內容簡潔扼要，僅需紀錄問題核心和解決方案，其他如除錯過程等資訊省略。
			- CollabrationGuide.md：團隊共同遵守的規則，例如本文件。
		- Missions/
			- YYYYMMDDTHHMM-簡短任務名稱/
				- general_info.md：含row idea, requirement, solution design, adr, closing summary, commit message等
				- progress_status.md：紀錄plan中的task執行進度
				- plan/
					- task_name1.md
						- spec
						- test result
						- review report
						- 錯誤分析報告及改善方案
					- task_name2.md
					- ...
		- README.md
		- Misc：存放其他不易分類的輔助資料
			- Logs/
				- 限定開發或測試環境，為了便利提供開發人員檢視 log 檔，統一放在專案目錄中。
				- 正式生產環境中，log 檔案應視作業系統規範及運行權限，放置於系統或使用者目錄下，專門用於儲存 app 資料的路徑。
		- Shared/：放置各服務、子專案或模組等共通的資產，如graphql 或資料庫的Schema定義等。
	4. 不用加 License 文件。
	5. 特殊功能性檔案，例如 GraphQL 的 Schema，不受上面規範限制，依慣例處理。
	6. 檔名（含副檔名）上限為 40 字元，目錄名上限為 28 字元，最大路徑長度 200 字元，最大目錄深度 6 層。路徑與層級計算皆由專案根目錄起算。
3. 版本管理：
	1. 使用 x.y.z（Semantic Versioning）三段版本號格式。
	   - z 版本號由你決定是否增加，一般而言如果是新增測試案例、編排格式調整、小規模性能優化、文件內容增刪等不影響主要邏輯，則無須更新版號。但若涉及使用者明確告知 issue 編號或重大 bug 修復，或新實現了功能，則應推進版號。
	   - x 和 y 版本號，由使用者決定，並將明確指示推進。
	2. commit message：
		- 內容及格式符合 Conventional Commits 規範。
		- body 中應包含當次 Work 的 Goal、Tasks，簡述即可。
		- 自定義 type：temp，用以表示進行到一半尚未完成的工作，此類型 commit 僅限本機儲存，避免 push 到 remote，並且下次 commit 應該使用 amend 模式進行覆蓋。
	3. 允許直接代替使用者 commit，不需提交 PR。
	4. 持續在相同的 branch 上，若需切換分支，使用者將會自行手動處理。
	5. 應使用.gitignore排除版本控制項目：
		- 密碼、API端點、access token 等敏感數據之設定文件，如.env。
		- 編譯、打包後的中間代碼或二進制文件，如 build\、dist\、\_\_pycache\_\_\\等。
		- IDE/linter 等輔助軟體設定檔、非直接相關的shell script等個人化資料，如 `.vscode`。
		- log 檔案。
4. 開發流程：
	1. 開發關鍵或複雜邏輯時，考慮使用「測試驅動開發（Test-Driven Development）」模式。
	2. 除非在調適模組載入前階段等必要情況，否則應避免操作標準輸出。一般發現標準輸出之資訊，應視為未受管理的例外。針對小範圍調適時，主要透過調適工具追蹤變數。執行進階複雜調適時，例如接入外部服務等可能造成未知問題，或需要報告運行狀態等場景，應將相關訊息保存至實體 log 檔案，且輸出訊息應包含等級。非正式生產環境時、應同時包含代碼行號及檔案位置等細部資訊。
## C. Python 編程

1. 環境：使用 Python 3.13 及 [uv](https://docs.astral.sh/uv/) 環境管理工具。盡量使用最新語法及特性。
2. 型別標註：一律使用 PEP 585 及其後（例如PEP 604）的型別標注語法，除非是不支援的特殊情況，否則盡量不要從 `typing` 模組導入。
3. 測試框架：一律使用 `pytest`，不使用 `unittest`。
4. 編碼風格：反覆思考代碼風格是否符合 **Zen of Python**。
5. 數據處理偏好：優先使用 `Polars`，以替代 `Pandas`。
6. 非同步處理：以 `asyncio` 優先，避免 multithread。
7. 禁止在 function、method 中直接 `return None` 或可能為`None`的變數。任何 invoke 返回`None`時，視為該 invoke 對象沒有回傳值。若需返回空值，應該採用空字串、0、空 list、False等，或是考慮使用[Result](https://pypi.org/project/result/)模組將`None`包裹起來。
8. 使用Pydantic作為資料定義媒介，如果需要和RDB資料庫整合，可以使用SQLModel替代SQLAlchemy ORM，如果需要和Graphql整合，可以使用`strawberry.experimental.pydantic`動態將Pydantic Model 轉換為 `strawberry.type`。

## D. JavaScript 編程與前端設計

1. 環境：
	1. 本地端使用 `Node.js` 22.x 或更新的LTS版本。優先使用 `pnpm` ，除非系統不提供才使用 `npm`，不使用 `yarn`。
	2. 瀏覽器端支援至 ECMAScript 2024。
2. 語法：一律使用 `TypeScript`。
3. JS代碼風格：
	1. 盡量使用函數式編程風格，所有存取的外部變數及物件，需透過函式參數顯式傳入。除非明確告知因功能上刻意需求，否則盡量避免修改傳入參數內部狀態。應先以 deepcopy 方式複製物件（可使用第三方套件），然後才進行修改。
	2. 全域變數儲存基本型別資料而非物件時，應使用const宣告並賦值。
	3. 禁止使用 var 宣告變數。禁止直接存取未使用關鍵字宣告的變數。
	4. 若有獨立名稱空間需求，應優先使用物件對變數進行封裝，必要時為其建立 getter 和 setter。謹慎使用閉包，以減少難以追蹤的複雜狀態。
	5. 定義通用物件，應使用 class 語法，避免使用傳統構造函式。
	6. 當使用者輸入的資料需要傳送至後端時，考慮使用 `Zod` 或類似套件定義資料模型，以便結構化的驗證。
4. 技術棧：
	1. 主架構：使用 `Svelte` 框架最新版本，當前為v3。
	2. UI介面：
		1. 使用  `Skeleton` 打造UI介面。
		2. 表格形式資料展示：使用`TanStack Table v8`。
	3. JS：為了生成簡潔優雅的代碼，優先使用 ECMAScript 新特性語法，若無 ES 直接支援，則利用 `lodash`或類似的高階函數套件。
	4. 後端API存取：封裝IO邏輯及狀態管理，並使用`Urql`等套件。
	5. 測試：使用`Vitest`、`Storybook`。
	6. Font、icon及各種依賴套件，盡量直接安裝於本地並合併打包，避免前端動態請求外部資源。（前端網路存取能力可能受限）
5. 前端設計：
	1. 使用響應式設計，視覺排版應可在豎向螢幕呈現良好的效果，元件互動邏輯應同時支援滑鼠及觸控，以便行動裝置螢幕操作。
	2. 設計自定義樣式時，盡量使用 Class Selectors 顯式指定，避免使用 Type Selectors。
	3. UI 以元件庫所提供的現成工具優先，若需要自定義細部元件時，依下列原則進行視覺風格設計：
		1. 使用扁平式、圓角、無框線等現代化風格。
		2. 盡量減少元件重疊，如為資料展示，優先以動態版面進行行內展開。
		3. 重疊元件使用過度動畫及背景顏色、透明度（可搭配模糊效果）等方式強調，避免使用框線及陰影。
		4. 元件設計合理尺寸，禁止使用會完全遮擋其他元件互動的尺寸或底部圖層，即使目的是顯示嚴重的警告或錯誤訊息。
	4. 除登入認證等基本資訊外，前端不做任何業務邏輯狀態持久化，包含cookie 和 Local Storage。靜態文件 cache 由CDN 和瀏覽器端自行管理。
	5. 簡單的幾何形狀，使用 SVG 格式（一般 icon 除外仍應使用專業css library）。
	6. 若有必要時，前端架構中應使用框架推薦的 Store 方案進行統一狀態管理。
	7. 大型非主要元件，考慮設定 lazy-load。
	8. 後端API呼叫或進行複雜運算時，應該顯示運行狀態，如spinner等，其位置應該限制在相關作用區域內，例如按鈕、資料列或各別元件等，不可阻擋其他介面互動。