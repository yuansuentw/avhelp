# 開發規範與技術棧

v0.0.1, last update：2025/7/27

---

# 編碼品質與架構設計

1. 先搜尋是否有合適的現成解決方案，以高階封裝的工具為優先，避免重複造輪子。但須權衡該工具成熟度、未來性以及應用負擔（避免 Overkill）。
2. 輸出成果必須以可拓展性、高可維護性為最優先。開發及 Review 時，都應反覆思考並檢查結構是否遵循 **GRASP**、**SOLID** 等原則，且排版、命名、文件及語意等是否符合 **Clean Code** 原則。
3. 建立任何物件或資產時，應遵守單一來源（Single Truth of Source）原則，以引用、繼承、擴充、代理為原則，避免資料複製或重複定義。
4. 良好的命名：
	1. 不要將型別直接編碼名稱中。例如不要為interface加上I開頭、使用Hungarian Notation風格或使用如userList等名稱。但GraphQL SDL定義或資料庫schema等有慣例或規範等特殊情況例外。
	2. function/ method，應該使用動詞表達，變數應該使用名詞表達，array/ list等結構使用複數名詞，boolean變數使用is/ has/ can/ able等。
	3. 命名應該能清楚表達語意，禁止使用data、obj、temp、i、j等難以判斷用途之名稱。
5. 針對較大規模專案，依照 Domain-Driven Develop 評估，切分為多個模組。各模組間嚴格以最低耦合度封裝，秉持單一職責原則，並考慮以微服務方式實作，以提升部署彈性及可拓展性。
6. 未來可能會隨版本異動的業務邏輯，應從代碼中抽離，獨立並使用與代碼無關之純邏輯形式表達，例如使用專門業務邏輯引擎驅動，或自定義的描述文件。
7. 除非使用者明確指示，開發行為如文件格式或代碼風格等，應符合業界慣例或公約。
8. 基於安全性考量，對於所有非可控之外部輸入/操作應永遠檢驗，包含但不限於使用者輸入、缺乏可信度的的三方套件、API endpoint、網路資源或磁碟檔案等。針對合理輸入值，以條件邏輯處理：對於異常值，以try-catch 方式例外處理。
9. 註釋應該謹慎，只針對不易直觀理解或特殊狀況註釋，避免無意義注釋干擾閱讀。例如下面時機：
	- 參考的物件行數距離較遠或跨文件。
	- 使用了特殊技巧或迂迴的方式（黑魔法）。
	- 經過與使用者反覆討論或經過多次修改才確認的邏輯。
10. 環境依賴：
	- 規劃架構時，盡量避免依賴特定作業系統、硬體或特殊權限（如 Redis、systemd、Registry 等）。可簡易下載執行、無須特殊權限且跨平台的外部程式（如 OpenCV）不受此限。
	- 涉及作業系統 I/O 時及進程管理時，應盡量跨平台相容。
	- 專案中任何涉及運行環境相關的參數，均獨立儲存於設定檔案，不可硬編碼。套件依賴相關應用專業套件/虛擬環境管理工具。

# 通用編程實踐

## 技術棧選擇

1. 資料庫操作：優先使用 ORM/ODM 框架，除非使用者明確指示效能為第一優先，才使用原生 SQL。
2. 前後端協議選擇：
	1. 應依照實際場景選擇使用API規範，以 GraphQL 優先，OpenAPI（RESTful）次之。前端應設計為具有 Route 的 SPA（Single Page Application），其次使用MPA SSR，避免傳統CSR架構。
	2. GraphQL的Type/Input命名，使用對應的suffix，Mutation操作則使用get、delete、update、create等動詞轉作為prefix。
	3. 依照OAuth 2.0 慣例設計使用者登入流程。
	4. 基於分散式服務需求，避免設計依賴後端狀態的請求。
3. 根據「Single Source of Truth」原則，針對微服務或前後端等通信，雙邊實體均需持有資料定義的場景時。先使用Code First方式定義「通用」資料結構物件，然後將該文件以工具轉換為「專用」文件。例：使用Python的`Pydantic`或`Strawberry`套件定義，透過`Strawberry CLI`轉換為 .graphql SDL 定義檔案，再使用`Graphql Codegen`進一步轉換為前端使用的ts型別。

## 開發流程

1. 開發關鍵或複雜邏輯時，考慮使用「測試驅動開發（Test-Driven Development）」模式。
2. 除非在調適模組載入前階段等必要情況，否則應避免操作標準輸出。一般發現標準輸出之資訊，應視為未受管理的例外。針對小範圍調適時，主要透過調適工具追蹤變數。執行進階複雜調適時，例如接入外部服務等可能造成未知問題，或需要報告運行狀態等場景，應將相關訊息保存至實體 log 檔案，且輸出訊息應包含等級。非正式生產環境時、應同時包含代碼行號及檔案位置等細部資訊。

---

# Python 編程

1. 環境：使用 Python 3.13 及 [uv](https://docs.astral.sh/uv/) 環境管理工具。盡量使用最新語法及特性。
2. 型別標註：一律使用 PEP 585 及其後（例如PEP 604）的型別標注語法，除非是不支援的特殊情況，否則盡量不要從 `typing` 模組導入。
3. 測試框架：一律使用 `pytest`，不使用 `unittest`。
4. 編碼風格：反覆思考代碼風格是否符合 **Zen of Python**。
5. 數據處理偏好：優先使用 `Polars`，以替代 `Pandas`。
6. 非同步處理：以 `asyncio` 優先，避免 multithread。
7. 禁止在 function、method 中直接 `return None` 或可能為`None`的變數。任何 invoke 返回`None`時，視為該 invoke 對象沒有回傳值。若需返回空值，應該採用空字串、0、空 list、False等，或是考慮使用[Result](https://pypi.org/project/result/)模組將`None`包裹起來。
8. 使用Pydantic作為資料定義媒介，如果需要和RDB資料庫整合，可以使用SQLModel替代SQLAlchemy ORM，如果需要和Graphql整合，可以使用`strawberry.experimental.pydantic`動態將Pydantic Model 轉換為 `strawberry.type`。

# JavaScript 編程與前端設計

## 環境

1. 本地端使用 `Node.js` 22.x 或更新的LTS版本。優先使用 `pnpm` ，除非系統不提供才使用 `npm`，不使用 `yarn`。
2. 瀏覽器端支援至 ECMAScript 2024。

## 語法

一律使用 `TypeScript`。

## JS代碼風格

1. 盡量使用函數式編程風格，所有存取的外部變數及物件，需透過函式參數顯式傳入。除非明確告知因功能上刻意需求，否則盡量避免修改傳入參數內部狀態。應先以 deepcopy 方式複製物件（可使用第三方套件），然後才進行修改。
2. 全域變數儲存基本型別資料而非物件時，應使用const宣告並賦值。
3. 禁止使用 var 宣告變數。禁止直接存取未使用關鍵字宣告的變數。
4. 若有獨立名稱空間需求，應優先使用物件對變數進行封裝，必要時為其建立 getter 和 setter。謹慎使用閉包，以減少難以追蹤的複雜狀態。
5. 定義通用物件，應使用 class 語法，避免使用傳統構造函式。
6. 當使用者輸入的資料需要傳送至後端時，考慮使用 `Zod` 或類似套件定義資料模型，以便結構化的驗證。

## 技術棧

1. 主架構：使用 `Svelte` 框架最新版本，當前為v3。
2. UI介面：
	1. 使用  `Skeleton` 打造UI介面。
	2. 表格形式資料展示：使用`TanStack Table v8`。
3. JS：為了生成簡潔優雅的代碼，優先使用 ECMAScript 新特性語法，若無 ES 直接支援，則利用 `lodash`或類似的高階函數套件。
4. 後端API存取：封裝IO邏輯及狀態管理，並使用`Urql`等套件。
5. 測試：使用`Vitest`、`Storybook`。
6. Font、icon及各種依賴套件，盡量直接安裝於本地並合併打包，避免前端動態請求外部資源。（前端網路存取能力可能受限）

## 前端設計

1. 使用響應式設計，視覺排版應可在豎向螢幕呈現良好的效果，元件互動邏輯應同時支援滑鼠及觸控，以便行動裝置螢幕操作。
2. 設計自定義樣式時，盡量使用 Class Selectors 顯式指定，避免使用 Type Selectors。
3. UI 以元件庫所提供的現成工具優先，若需要自定義細部元件時，依下列原則進行視覺風格設計：
	1. 使用扁平式、圓角、無框線等現代化風格。
	2. 盡量減少元件重疊，如為資料展示，優先以動態版面進行行內展開。
	3. 重疊元件使用過度動畫及背景顏色、透明度（可搭配模糊效果）等方式強調，避免使用框線及陰影。
	4. 元件設計合理尺寸，禁止使用會完全遮擋其他元件互動的尺寸或底部圖層，即使目的是顯示嚴重的警告或錯誤訊息。
4. 除登入認證等基本資訊外，前端不做任何業務邏輯狀態持久化，包含cookie 和 Local Storage。靜態文件 cache 由CDN 和瀏覽器端自行管理。
5. 簡單的幾何形狀，使用 SVG 格式（一般 icon 除外仍應使用專業css library）。
6. 若有必要時，前端架構中應使用框架推薦的 Store 方案進行統一狀態管理。
7. 大型非主要元件，考慮設定 lazy-load。
8. 後端API呼叫或進行複雜運算時，應該顯示運行狀態，如spinner等，其位置應該限制在相關作用區域內，例如按鈕、資料列或各別元件等，不可阻擋其他介面互動。